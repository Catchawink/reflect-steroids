#![doc = include_str!("../README.md")]
#![deny(missing_docs, clippy::useless_conversion, clippy::useless_asref)]
#![warn(clippy::pedantic)]

mod cast;
mod downcast;
mod dynamic_trait;
mod error;
pub mod serialization;
mod type_registry;

pub use cast::*;
pub use downcast::*;
pub use dynamic_trait::*;
pub use error::*;
pub use type_registry::*;

#[doc(no_inline)]
pub use bevy_reflect as reflect;

#[doc(no_inline, hidden)]
pub use serde;

/// Prelude
pub mod prelude {
    #[doc(no_inline)]
    pub use super::{
        impl_dynamic_trait, reflect::prelude::*, Cast as _, CastBox as _, CastMut as _,
        CastRef as _, DowncastReflect, DynamicTraitExt as _, TypeRegistryExt as _,
    };

    #[doc(no_inline)]
    #[cfg(feature = "inventory")]
    pub use super::enable_global_type_registration;
}

/// Implement [`DynamicTrait`] for a trait object.
///
/// This enables dynamic trait casting for `dyn MyTrait`, via
/// [`bevy_reflect::TypeRegistry`].
///
/// The second argument is the "hidden" [`TypeData`](bevy_reflect::TypeData) of
/// the trait, generated by [`#[reflect_trait]`](bevy_reflect::reflect_trait).
/// The name of this type is "ReflectXYZ", where "XYZ" is the name of the trait.
///
/// This macros implements the following:
///
/// - [`DynamicTrait`] for `dyn MyTrait`.
/// - [`DynamicCaster`] for `ReflectMyTrait`.
/// - [`Reflect`](bevy_reflect::Reflect) for `Box<dyn MyTrait>`, which forwards
///   all reflection to the concrete type (meaning it can be reflected upon as
///   if it was `Box<dyn Reflect>`).
/// - [`std::fmt::Debug`] for `dyn MyTrait` (forwarding to
///   [`Reflect::debug()`](bevy_reflect::Reflect::debug)).
/// - [`Serialize`](serde::Serialize) for `dyn MyTrait` (see [serialization]).
/// - [`Deserialize`](serde::Deserialize) for `Box<dyn MyTrait>` (see
///   [serialization]).
/// - A downcasting interface for `dyn MyTrait`, similar to `dyn Reflect` and
///   `dyn Any`.
///
/// ## Usage
///
/// ```rust
/// # use reflect_steroids::prelude::*;
/// #[reflect_trait]
/// trait MyTrait: DowncastReflect {}
///
/// impl_dynamic_trait!(MyTrait, ReflectMyTrait);
///
/// #[derive(Reflect)]
/// #[reflect(MyTrait)]
/// struct Foo;
///
/// impl MyTrait for Foo {}
///
/// let foo = &Foo;
/// let foo_as_mytrait: &dyn MyTrait = foo;
/// let foo_as_reflect = foo_as_mytrait.as_reflect();
/// assert_eq!(foo_as_reflect.type_name(), std::any::type_name::<Foo>());
/// ```
#[macro_export]
macro_rules! impl_dynamic_trait {
    ($trait_name:ident, $type_data_name:ident) => {
        impl $crate::DynamicTrait for dyn $trait_name {
            type TypeData = $type_data_name;

            fn reflect_name() -> &'static str {
                stringify!($trait_name)
            }
        }

        impl $crate::DynamicCaster<dyn $trait_name> for $type_data_name {
            fn from_reflect(&self, this: Box<dyn $crate::reflect::Reflect>) -> Box<dyn $trait_name> {
                self.get_boxed(this).unwrap()
            }

            fn from_reflect_ref<'a>(&self, this: &'a dyn $crate::reflect::Reflect) -> &'a dyn $trait_name {
                self.get(this).unwrap()
            }

            fn from_reflect_mut<'a>(&self, this: &'a mut dyn $crate::reflect::Reflect) -> &'a mut dyn $trait_name {
                self.get_mut(this).unwrap()
            }
        }

        #[allow(dead_code)]
        impl dyn $trait_name {
            #[doc = "Returns `true` if the underlying value is of type `T`, or `false` otherwise."]
            #[doc = ""]
            #[doc = "The underlying value is the concrete type that is stored in this `dyn` object; it can be downcasted to."]
            pub fn is<T: $trait_name>(&self) -> bool {
                self.as_reflect().is::<T>()
            }

            #[doc = "Downcasts the value to type `T`, consuming the trait object."]
            #[doc = ""]
            #[doc = "If the underlying value is not of type `T`, returns `Err(self)`."]
            pub fn downcast<T: $trait_name>(self: Box<Self>) -> Result<Box<T>, Box<Self>> {
                if self.is::<T>() {
                    Ok(<dyn $crate::reflect::Reflect>::downcast(
                        $crate::DowncastReflect::downcast_into_reflect(self),
                    )
                    .unwrap())
                } else {
                    Err(self)
                }
            }

            #[doc = "Downcasts the value to type `T` by reference."]
            #[doc = ""]
            #[doc = "If the underlying value is not of type `T`, returns `None`."]
            pub fn downcast_ref<T: $trait_name>(&self) -> Option<&T> {
                self.as_reflect().downcast_ref()
            }

            #[doc = "Downcasts the value to type `T` by mutable reference."]
            #[doc = ""]
            #[doc = "If the underlying value is not of type `T`, returns `None`."]
            pub fn downcast_mut<T: $trait_name>(&mut self) -> Option<&mut T> {
                self.as_reflect_mut().downcast_mut()
            }

            #[doc = "Cast this trait object to `dyn Reflect`."]
            #[doc = ""]
            #[doc = concat!("This cannot fail because `", stringify!($trait_name), ": DowncastReflect`.")]
            pub fn into_reflect(self: Box<Self>) -> Box<dyn $crate::reflect::Reflect> {
                $crate::DowncastReflect::downcast_into_reflect(self)
            }
        }

        impl $crate::reflect::Reflect for Box<dyn $trait_name> {
            fn type_name(&self) -> &str {
                (**self).as_reflect().type_name()
            }

            fn get_type_info(&self) -> &'static bevy_reflect::TypeInfo {
                (**self).as_reflect().get_type_info()
            }

            fn into_any(self: Box<Self>) -> Box<dyn ::core::any::Any> {
                $crate::reflect::Reflect::into_any($crate::DowncastReflect::downcast_into_reflect(
                    self,
                ))
            }

            fn as_any(&self) -> &dyn ::core::any::Any {
                (**self).as_reflect().as_any()
            }

            fn as_any_mut(&mut self) -> &mut dyn ::core::any::Any {
                (**self).as_reflect_mut().as_any_mut()
            }

            fn as_reflect(&self) -> &dyn $crate::reflect::Reflect {
                (**self).as_reflect().as_reflect()
            }

            fn as_reflect_mut(&mut self) -> &mut dyn $crate::reflect::Reflect {
                (**self).as_reflect_mut().as_reflect_mut()
            }

            fn apply(&mut self, value: &dyn $crate::reflect::Reflect) {
                (**self).as_reflect_mut().apply(value)
            }

            fn set(&mut self, value: Box<dyn $crate::reflect::Reflect>) -> Result<(), Box<dyn $crate::reflect::Reflect>> {
                (**self).as_reflect_mut().set(value)
            }

            fn reflect_ref(&self) -> bevy_reflect::ReflectRef {
                (**self).as_reflect().reflect_ref()
            }

            fn reflect_mut(&mut self) -> bevy_reflect::ReflectMut {
                (**self).as_reflect_mut().reflect_mut()
            }

            fn clone_value(&self) -> Box<dyn $crate::reflect::Reflect> {
                (**self).as_reflect().clone_value()
            }

            fn reflect_hash(&self) -> Option<u64> {
                (**self).as_reflect().reflect_hash()
            }

            fn reflect_partial_eq(&self, value: &dyn $crate::reflect::Reflect) -> Option<bool> {
                (**self).as_reflect().reflect_partial_eq(value)
            }

            fn debug(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                (**self).as_reflect().debug(f)
            }

            fn serializable(&self) -> Option<$crate::reflect::serde::Serializable<'_>> {
                (**self).as_reflect().serializable()
            }
        }

        impl $crate::reflect::FromReflect for Box<dyn $trait_name> {
            fn from_reflect(_: &dyn $crate::reflect::Reflect) -> Option<Self> {
                None
            }
        }

        impl ::core::fmt::Debug for dyn $trait_name {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                self.as_reflect().debug(f)
            }
        }

        impl $crate::serde::Serialize for dyn $trait_name {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: $crate::serde::Serializer,
            {
                $crate::serialization::serialize(self.as_reflect(), serializer)
            }
        }

        impl<'de> $crate::serde::Deserialize<'de> for Box<dyn $trait_name> {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: $crate::serde::Deserializer<'de>,
            {
                let box_dyn_reflect = $crate::serialization::deserialize(deserializer)?;
                $crate::Cast::try_cast(box_dyn_reflect).map_err($crate::serde::de::Error::custom)
            }
        }
    };
}

#[cfg(feature = "inventory")]
#[doc(hidden)]
pub use inventory;

#[cfg(feature = "inventory")]
#[doc(hidden)]
pub mod global_registration {
    use bevy_reflect::TypeRegistry;

    pub struct RegisterFn(pub fn(&mut TypeRegistry));
}

/// Include a type in the global list of registered types.
///
/// This makes the type available in any `TypeRegistry` where
/// [`register_global_types()`](TypeRegistryExt::register_global_types) is
/// called.
///
/// The pros and cons of this facility is that it decentralizes type
/// registration. Any crate can register types, and whoever creates the
/// `TypeRegistry` does not need to worry about missing something. However, this
/// also makes it more difficult to control which types are part of the
/// registry, potentially causing it to grow very large.
#[cfg(feature = "inventory")]
#[macro_export]
macro_rules! enable_global_type_registration {
    ($t:ty) => {
        $crate::inventory::submit! {
            $crate::global_registration::RegisterFn(|registry| registry.register::<$t>())
        }
    };
}
